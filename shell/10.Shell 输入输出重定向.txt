 
//=========================================描述 
//=========================================描述 
//=========================================描述
	大多数UNIX系统命令
	从"你的终端"接受"输入"并将所"产生的输出"发
	送回到"您的终端"。
	//========================
	一个命令通常从一个叫"标准输入的地方读取输入"，
		//默认情况下，这恰好是你的终端。
	一个命令通常将其"输出写入到标准输出"，
		//默认情况下，这也是你的终端。
	//========================一波命令
	命令				说明
	command > file		将输出重定向到 file。
			//$who > users
	command >> file		将输出以追加的方式重定向到 file。
			//$who >> users
	command < file		将输入重定向到 file。			
	//========================一波命令
	命令				说明	
	n > file			将文件描述符为 n 的文件重定向到 file。
	n >> file			将文件描述符为 n 的文件以追加的方式重定向到 file。		
	//========================第一波命令
	命令				说明	
	n >& m				将输出文件 m 和 n 合并。
	n <& m				将输入文件 m 和 n 合并。
	<< tag				将开始标记 tag 和结束标记 tag 之间的内容作为输入。	
	//========================文件描述符
	0 		通常是标准输入（STDIN），
			//标准输入文件(stdin)：stdin的文件描述符为0，
			//Unix程序默认从stdin读取数据。
	1 		是标准输出（STDOUT），
			//标准输出文件(stdout)：stdout 的文件描述符为1，
			//Unix程序默认向stdout输出数据。
	2 		是标准错误输出（STDERR）。
			//标准错误文件(stderr)：stderr的文件描述符为2，
			//Unix程序会向stderr流中写入错误信息。
	//========================================
		如果希望 stderr 重定向到 file，可以这样写：
		command 2 > file
		command 2 >> file
	//========================================	
		如果希望将 stdout 和 stderr 合并后重定向到 file，		
		command > file 2>&1
		command >> file 2>&1
	//========================================		
		如果希望对 stdin 和 stdout 都重定向
		command < file1 >file2
//=========================================Here Document
//=========================================Here Document
//=========================================Here Document
	Here Document 是 Shell 中的一种特殊的重定向方式，
	用来将"输入重定向"到一个交互式 Shell 脚本或程序。
	//============格式：
		command << delimiter
			document
		delimiter	
		
		/**
		
		说明：
			它的作用是将两个 delimiter 之间的内容(document) 
			作为输入传递给 command。	
				1).结尾的delimiter 一定要顶格写，
					前面不能有任何字符，
					后面也不能有任何字符，
					包括空格和 tab 缩进。
				2).开始的delimiter前后的空格会被忽略掉。
					
		*/
		//=========示例1：wc -l
		wc -l << EOF
			你们
			好
			吗
			？
		EOF
		//=========示例2：cat
		cat << EOF
			你们
			好
			吗
			？
		EOF
//=========================================/dev/null 文件
//=========================================/dev/null 文件	
//=========================================/dev/null 文件	
		如果希望执行某个命令，
		但又不希望在屏幕上显示输出结果，
		那么可以将输出重定向到 /dev/null：
		
		command > /dev/null
	
		/dev/null 是一个特殊的文件
		写入到它的内容都会被丢弃；
		//====
		如果尝试从该文件读取内容，
		那么什么也读不到。
		//====
		将命令的输出重定向到它，
		会起到"禁止输出"的效果。
		//====
		如果希望屏蔽 stdout 和 stderr，可以这样写
		command > /dev/null 2>&1
	
//=========================================Shell 文件包含
//=========================================Shell 文件包含
//=========================================Shell 文件包含
		和其他语言一样，
		Shell 也可以包含外部脚本。
		这样可以很方便的封装一些公用的代码作为一个独立的文件。
		//========格式：
			. filename
			source filename
			/**
			注意：. 号 和文件名之间有空格
			*/
		//========示例1	使用 . 号来引用test1.sh 文件
		. ./test1.sh
		//========示例2	或者使用以下包含文件代码
		source ./test1.sh
	
// shell命令输出内容开头增加日期时间
产生输出的shell命令 | awk '{ print strftime("%Y-%m-%d %H:%M:%S: "), $0; fflush(); }'
	
	
